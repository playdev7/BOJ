# 다이얼은 1부터 반시계방향으로 0까지 간다.
# 1을 당기려면 2초, 2를 당기려면 3초, ...
# 즉, 기본적으로 1은 2초이고, 그 다음의 숫자를 당기려면 1보다 거리가 먼 만큼 1초씩 추가된다.
# 추가로, 다이얼에는 임의의 알파벳이 기재되어 있다.
# 문제 - 알파벳 문자열이 주어지면 문자열에 대응하는 다이얼을 걸기 위한 최소 시간을 출력하는 프로그램 만들기.

# 아날로그 다이얼의 구조에 맞도록 딕셔너리 dial 선언
dial = {
    1: "1",
    2: ["A", "B", "C"],
    3: ["D", "E", "F"],
    4: ["G", "H", "I"],
    5: ["J", "K", "L"],
    6: ["M", "N", "O"],
    7: ["P", "Q", "R", "S"],
    8: ["T", "U", "V"],
    9: ["W", "X", "Y", "Z"],
    # OPERATOR는 사칙연산자만?
    0: ["+", "-", "*", "/"]
}


# 필요한 변수 선언
# 임의의 문자열 num_text 입력받기
num_text = input()

# 문자열에 대응하는 실제 번호 리스트 numbers 선언
numbers = []

# 다이얼을 거는 최종 시간 result 선언.
result = 0

# 문자열을 실제 전화번호로 만들기.
# num_text 문자열의 각 알파벳 i를 순차대로 대입
for i in num_text:
    # 딕셔너리 items() 메소드 활용하여 key와 value 대입
    for key, value in dial.items():
        # i가 value에 포함되면 해당 키가 숫자로 된 번호임.
        # 해당 키를 numbers 리스트의 원소로 추가
        if i in value:
            numbers.append(key)
        else:
            pass


# 실제 전화번호를 다이얼로 걸기 위해 필요한 최소 시간 구하기
# 1은 2초, 1보다 큰 수는 1씩 추가 됨
# 즉, 다이얼 한 번 당 자기 숫자 + 1 만큼의 시간이 소요 됨.
for i in numbers:
    # 0만 11로 보정해주면 됨.
    if i == 10:
        result += 11
    else:
        result += i + 1

print(result)